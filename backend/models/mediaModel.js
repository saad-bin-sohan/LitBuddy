// backend/models/mediaModel.js
/**
 * Media model
 *
 * Stores metadata for uploaded evidence files (avatars/selfies/proofs/screenshots).
 * This keeps large binaries out of other documents and allows separate retention,
 * virus/NSFW scanning, signed-URL serving and later switching to S3/CDN.
 */

const mongoose = require('mongoose');

const MediaSchema = new mongoose.Schema(
  {
    owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true }, // who uploaded the file (may be reporter)
    originalName: { type: String, required: true },
    filename: { type: String, required: true }, // on-disk or S3 key
    mimeType: { type: String, required: true },
    size: { type: Number, required: true }, // bytes
    storage: { type: String, enum: ['local', 's3'], default: 'local' },
    path: { type: String }, // local absolute path or S3 key
    url: { type: String }, // public/signed url (optional; generated by service when needed)
    report: { type: mongoose.Schema.Types.ObjectId, ref: 'Report', index: true, default: null }, // report this file is attached to
    moderationStatus: { type: String, enum: ['pending', 'approved', 'rejected', 'flagged'], default: 'pending' },
    meta: { type: mongoose.Schema.Types.Mixed, default: {} }, // for thumbnails, EXIF, detection results, etc.
    removed: { type: Boolean, default: false }, // soft-delete flag
    removedAt: Date,
  },
  { timestamps: true }
);

// index for cleanup & queries
MediaSchema.index({ createdAt: 1 });
MediaSchema.index({ owner: 1, report: 1 });

/**
 * toJSON hook: hide internal path on API responses but keep useful fields
 */
MediaSchema.set('toJSON', {
  transform(doc, ret) {
    delete ret.__v;
    // hide filesystem path by default
    if (ret.path && ret.storage === 'local') {
      delete ret.path;
    }
    return ret;
  },
});

module.exports = mongoose.model('Media', MediaSchema);
